## 1. Архитектура сервера

### 1.1. Internal event pool `epoll`
Вместо создания отдельного потока на каждое соединение (модель thread-per-connection), используется один поток, который управляет всеми событиями через `epoll`.

**Плюсы:**
*   Нету переключения между потоками и не нужно ими управлять
*   Минимальный объем памяти.

### 1.2. Механизм Edge Triggered (ET)

В режиме `ET(EPOLLET)` ядро уведомляет процесс только при изменении состояния сокета, читаем данные до `EAGAIN` через `recv`. 

### 1.3. Управление состоянием клиентов
Так как TCP — это потоковый протокол, данные могут приходить частями (например, сначала 4 байта заголовка, затем остальное). Для каждого клиента хранится структура `ClientInfo`:
*   Буфер для накопления данных.
*   Счетчик полученных байт.
*   Флаг состояния (получен заголовок или нет).
*   Время последней активности для реализации таймаута.

---

## 2. Протокол передачи данных
Сообщение состоит из двух частей:
1.  **Заголовок (Header):** 8 байт (4 байта `type`, 4 байта `size`).
2.  **Полезная нагрузка (Payload):** переменная длина (0–1016 байт).

**Алгоритм обработки входящего потока:**
1.  Если накоплено < 8 байт — ждем дочитывания заголовка.
2.  После получения заголовка проверяем валидность `size`.
3.  Ждем накопления `8 + size` байт.
4.  Выполняем операцию (Echo) и сдвигаем буфер через `memmove`, если в нем остались данные следующего сообщения.

---

## 3. Схемы

### 3.1. Жизненный цикл обработки события (Sequence Diagram)

в файле `tcp_echo.drawio.png`


---

## 4. Дизайн клиента (Тестовый модуль)
Клиент спроектирован как стресс-тест:
1.  **Множественность:** Создает `N` сокетов.
2.  **Асинхронность:** Хотя клиент может быть простым, он последовательно проверяет каждое соединение:
    *   Генерация случайного типа и размера.
    *   Заполнение payload случайными данными.
    *   Отправка -> Ожидание ответа -> Сравнение байт-в-байт.
3.  **Верификация:** Если ответ сервера не совпал с отправленным сообщением, клиент сообщает об ошибке.

---

## 5. Механизмы обслуживания соединений
*   **Таймауты:** Раз в итерацию основного цикла сервер проходит по списку клиентов и закрывает тех, у кого `now - last_activ > 30s`. Это защищает от "зависших" соединений.
*   **Статистика:** Глобальный объект `Stats` инкрементируется при каждом событии. Раз в секунду данные выводятся в `stdout`.


## 6. Возможные проблемы или улучшения
* Если один из клиентов будет отправлять данные без остановки, есть риск что остальные клиенты не будут обслужены. 
Возможное решение - ввод ограничение на осблуживание клдиентов, например для каждого клиента по 10 сообщений за раз.
* Соединение обрываются сразу после установки при достижении лимита активных соединений